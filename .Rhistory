Bdelta <- matrix(c(0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0),nrow=4,ncol=4,byrow=TRUE)
Bepsilon <- matrix(c(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0),nrow=4,ncol=4,byrow=TRUE)
Beta <- matrix(c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0),nrow=4,ncol=4,byrow=TRUE)
Ntotalpha <- al*sum(EXPM(symGTRRateM,Balpha)*ObsM/TransM)
Ntotbeta <- be*sum(EXPM(symGTRRateM,Bbeta)*ObsM/TransM)
Ntotgamma <- ga*sum(EXPM(symGTRRateM,Bgamma)*ObsM/TransM)
Ntotdelta <- del*sum(EXPM(symGTRRateM,Bdelta)*ObsM/TransM)
Ntotepsilon <- eps*sum(EXPM(symGTRRateM,Bepsilon)*ObsM/TransM)
Ntoteta <- eta*sum(EXPM(symGTRRateM,Beta)*ObsM/TransM)
## Total expected time (we have unit time between sequences)
Ttot <- n #The same for all estimates, since every estimate i N_i/T_i for i = alpha,...,eta
##------------------------------------------
## M-step
##------------------------------------------
alNew <- Ntotalpha /Ttot
beNew <- Ntotbeta/Ttot
gaNew <- Ntotgamma/Ttot
delNew <- Ntotdelta/Ttot
epsNew <- Ntotepsilon/Ttot
etaNew <- Ntoteta/Ttot
cat("Iteration:",iter," Estimate of alpha:",round(alNew,digits=3), " Estimate of beta:",round(beNew,digits=3),
" Estimate of gamma",round(gaNew,digits=3), " Estimate of delta:",round(delNew,digits=3),
" Estimate of epsilon:",round(epsNew,digits=3), " Estimate of eta:",round(etaNew,digits=3))
al <- alNew
be <- beNew
ga <- gaNew
del <- delNew
eps <- epsNew
eta <- etaNew
alsymGTR[iter] <- al
besymGTR[iter] <- be
gasymGTR[iter] <- ga
delsymGTR[iter] <- del
epssymGTR[iter] <- eps
etasymGTR[iter] <- eta
##-------------------------------------------
## Monitor log-likelihood
symGTRRateM <- symGTRRateMFct(al, be, ga, del, eps, eta)
TransM <- expm(symGTRRateM)
logLk <- sum(ObsM*log(TransM))
cat(" log-likelihood:",logLk,"\n")
logLksymGTR[iter] <- logLk
}
cat("EM estimate of alpha:",al,"\n", "EM estimate of beta:",be,"\n", "EM estimate of gamma:",ga,"\n",
"EM estimate of delta:",del,"\n", "EM estimate of epsilon:",eps,"\n", "EM estimate of eta:",eta,"\n")
2*(-6692.135+7833.194)
2*(-7833.194 - (-6692.135))
Balpha <- matrix(c(0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),nrow=4,ncol=4,byrow=TRUE)
Bbeta <- matrix(c(0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0), nrow = 4, ncol = 4, byrow = TRUE)
Bgamma <- matrix(c(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0),nrow=4,ncol=4,byrow=TRUE)
Bdelta <- matrix(c(0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0),nrow=4,ncol=4,byrow=TRUE)
Bepsilon <- matrix(c(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0),nrow=4,ncol=4,byrow=TRUE)
Beta <- matrix(c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0),nrow=4,ncol=4,byrow=TRUE)
Balpha
Bbeta
Bgamma
Bdelta
Bepsilon
Beta
symGTRRateMFct(1, 2, 3, 4, 5, 6)
1632+1644
920+1038
1025+1036
1325+1380
3276+1958+2061+2705
library(imager)
library(spatstat)
#Sets layout in plots (3x3 matrix)
layout(matrix(c(1:9), ncol=3))
#Loads Original image, which is a Window of a bread image
im <- load.image("brødwind.JPG")
##-------------------------------------------------------------
# Plots Original image, Original grayscaled image and Original
# image with threshold determined from Kmeans
##-------------------------------------------------------------
plot(im, main = "Original")
im.gray <- im %>% grayscale
plot(im.gray, main = "Original")
im.thres <- threshold(im.gray, "auto", TRUE)
plot(im.thres, main = "Original")
##-------------------------------------------------------------
# Plots anisotropic blurred image with a certain amplitude and
# sharpness, and thereafter the grayscaled version and the
# image with threshold determined from Kmeans
##-------------------------------------------------------------
im.blur.anis <- blur_anisotropic(im,ampl=1e4,sharp=1)
plot(im.blur.anis, main = "Anisotropic blur")
im.gray.anis <- im.blur.anis %>% grayscale
plot(im.gray.anis, main = "Anisotropic blur")
im.thres.anis <- threshold(im.gray.anis, "auto", TRUE)
plot(im.thres.anis, main = "Anisotropic blur")
##-------------------------------------------------------------
# Plots isotropic (Gaussian) blurred image with a certain std.
# div., and thereafter the grayscaled version and the image
# with threshold determined from Kmeans
##-------------------------------------------------------------
im.blur <- isoblur(im, 3, neumann = FALSE, gaussian = TRUE)
plot(im.blur, main = "Isotropic blur")
im.gray.blur <- im.blur %>% grayscale
plot(im.gray.blur, main = "Isotropic blur")
im.thres.blur <- threshold(im.gray.blur, "auto", TRUE)
plot(im.thres.blur, main = "Isotropic blur")
####Laslett####
layout(1)
im.thres = cimg2im(im.thres)
laslett = laslett(im.thres)
im.thres.anis = cimg2im(im.thres.anis)
laslett = laslett(im.thres.anis)
im.thres.blur = cimg2im(im.thres.blur)
laslett = laslett(im.thres.blur)
setwd("C:/Users/livmb/Dropbox/UNI/Speciale/Brød billeder/brød")
library(imager)
library(spatstat)
#Sets layout in plots (3x3 matrix)
layout(matrix(c(1:3), ncol=3))
#Loads Original image, which is a Window of a bread image
im <- load.image("BlåBrødPågen7cmTop.JPG")
##-------------------------------------------------------------
#### Picture Manipulation ####
##-------------------------------------------------------------
# Plots Original image, extracted Blue channel image and the
# thresholded version of this. The threshold is here determined
# by Kmeans.
##-------------------------------------------------------------
layout(matrix(c(1:3), ncol=3))
plot(im, xlab = "", ylab = "")
BRGim <- B(im) - (R(im)+G(im)) #Extracting the blue colorchanel in the Original Image
BRGim.normalize <- (BRGim - min(BRGim))/(max(BRGim)-min(BRGim)) #Normalizes to image values
plot(BRGim.normalize, xlab = "", ylab = "")
thres.im <- threshold(BRGim.normalize, thr = "auto") #Thresholded Image
plot(thres.im, xlab = "", ylab = "")
##-------------------------------------------------------------
# Plotting the thresholded image in a observation
# window, W, and then performing Lasletts test.
##-------------------------------------------------------------
layout(1)
thres.im <- cimg2im(thres.im) #Change the image type
W <- owin(c(thres.im$xrange[1], thres.im$xrange[2]), c(thres.im$yrange[1], thres.im$yrange[2])) #defining the obs window W, here we just look at the whole image
Y <- thres.im[W]
top.length = 7 #cm
top.pix <- W$xrange[2]-W$xrange[1] #1381 pix
pixel.width = top.length/top.pix #How many cm the width of one pixel is
pixel.height = pixel.width #pixels are quadratic
pixel.area = pixel.width * pixel.height #area of one pixel in cm^2
area.W <- area(W)*pixel.area #area of W in cm^2
area.W
laslett = laslett(Y, plotit = F) #Lasletts transformation
W.prime.prime = laslett$Rect
x.point <- laslett$df$newx
y.point <- laslett$df$y
X <- ppp(x.point, y.point, W.prime.prime)
plot(X, main = "")
no.points.W.prime.prime <- X$n #135
area.W.prime.prime = area(W.prime.prime)*pixel.area #cm^2
clarkevans.test(X) #alternative="two.sided"
clarkevans.test(X, correction="D", nsim = 10^4) #alternative="two.sided" + Donnelly correction
gamma.hat = no.points.W.prime.prime/area.W.prime.prime #57.5285
no.black.particles <- sum(thres.im < 1) #number of black particles in the thresholded image
p.hat <- no.black.particles/area(W) #Because area.W.pix = no.black.particles + no.white.particles = total number of particles in W
p.hat
r.zero.hat <- sqrt(-(log(1-p.hat))/(gamma.hat*pi))
r.zero.hat
gamm
gamma.hat
p.hat
r.zero.hat <- sqrt(-(log(1-p.hat))/(gamma.hat*pi))
r.zero.hat
#----------------#
#Estimate of r_0
r.zero.hat <- sqrt(-(log(1-p.hat))/(gamma.hat*pi))
#Covariogram fct for B^2
F2 <- function(x){
if(0 < x && x < 2*r.zero.hat){
F2 <- ((4*x)/(pi*r.zero.hat^2))*(acos(x/(2*r.zero.hat)) - (x/(2*r.zero.hat))*sqrt(1-(x^2/(4*r.zero.hat^2))))
} else{
F2 <- 0
}
return(F2)
}
F2 <- Vectorize(F2);
curve(F2, 0-0.1, 2*r.zero.hat+0.1)
int <- function(x){
return((exp(gamma.hat*r.zero.hat^2*(F2(x/r.zero.hat)))-1)*x)
}
int <- integrate(int, 0, Inf)$value #1.51875e-05
int
sigma.hat <- 2*pi*(1-p.hat)^2*int #3.689225e-05
sigma.hat
0.00003.689225
0.00003689225
3.689225*10^{-5}
area([-Inf, Inf]x[-Inf, Inf])
W
area([0.5, 1381.5] x [0.5, 466.5])
area(W)
KI = c(p.hat - 1.96*sqrt(1/area.W)*sqrt(sigma.hat), p.hat + 1.96*sqrt(1/area.W)*sqrt(sigma.hat)) #[0.3663183 0.3901280]
KI
qnorm(0.975)
KI = c(p.hat - qnorm(0.975)*sqrt(1/area.W)*sqrt(sigma.hat), p.hat + qnorm(0.975)*sqrt(1/area.W)*sqrt(sigma.hat)) #[0.3663183 0.3901280]
KI''
KI
p.hat
sigma.hat
Y
plot(Y)
W
W$xrange
W$xrange/2
0.5/2
W$xrange
W$xrange[1]
W$xrange[2]/2
1381.5/2
W$xrange[2]/2-r.zero.hat
r.zero.hat
1381.5/2-r.zero.hat
1381/2
thres.im$xrange[1]
W.one <- owin(c(0.5, 690.5-r.zero.hat), c(690.5+r.zero.hat, 1381.5))
W$yrange
466
466/2
W.one <- owin(c(0.5, 690.5-r.zero.hat), c(0.05, 233-r.zero.hat))
W.one
Y
W.one <- owin(c(0.5, 690.5-r.zero.hat), c(0.05, 233-r.zero.hat))
W.two <- owin(c(690.5+r.zero.hat, 1381.5), c(0.05, 233+r.zero.hat))
W.one
W.two
W.one <- owin(c(0.5, 690.5-r.zero.hat), c(0.5, 233-r.zero.hat))
W.two <- owin(c(690.5+r.zero.hat, 1381.5), c(0.5, 233+r.zero.hat))
W.one <- Y[W.one]
W.two <- Y[W.two]
W.one <- owin(c(0.5, 690.5-r.zero.hat), c(0.5, 233-r.zero.hat))
W.two <- owin(c(690.5+r.zero.hat, 1381.5), c(0.5, 233+r.zero.hat))
W.one <- Y[W.one]
W.two <- Y[W.two]
plot(Y)
W.one <- owin(c(0.5, 690.5-r.zero.hat), c(0.5, 233-r.zero.hat))
W.one <- Y[W.one]
plot(W.one)
W.two <- Y[W.two]
plot(W.two)
setwd("C:/Users/livmb/Dropbox/UNI/Speciale/Brød billeder/brød")
library(imager)
library(spatstat)
#Sets layout in plots (3x3 matrix)
layout(matrix(c(1:3), ncol=3))
#Loads Original image, which is a Window of a bread image
im <- load.image("BlåBrødPågen7cmTop.JPG")
##-------------------------------------------------------------
#### Picture Manipulation ####
##-------------------------------------------------------------
# Plots Original image, extracted Blue channel image and the
# thresholded version of this. The threshold is here determined
# by Kmeans.
##-------------------------------------------------------------
layout(matrix(c(1:3), ncol=3))
plot(im, xlab = "", ylab = "")
BRGim <- B(im) - (R(im)+G(im)) #Extracting the blue colorchanel in the Original Image
BRGim.normalize <- (BRGim - min(BRGim))/(max(BRGim)-min(BRGim)) #Normalizes to image values
plot(BRGim.normalize, xlab = "", ylab = "")
thres.im <- threshold(BRGim.normalize, thr = "auto") #Thresholded Image
plot(thres.im, xlab = "", ylab = "")
##-------------------------------------------------------------
# Plotting the thresholded image in a observation
# window, W, and then performing Lasletts test.
##-------------------------------------------------------------
layout(1)
thres.im <- cimg2im(thres.im) #Change the image type
W <- owin(c(thres.im$xrange[1], thres.im$xrange[2]), c(thres.im$yrange[1], thres.im$yrange[2])) #defining the obs window W, here we just look at the whole image
Y <- thres.im[W]
top.length = 7 #cm
top.pix <- W$xrange[2]-W$xrange[1] #1381 pix
pixel.width = top.length/top.pix #How many cm the width of one pixel is
pixel.height = pixel.width #pixels are quadratic
pixel.area = pixel.width * pixel.height #area of one pixel in cm^2
area.W <- area(W)*pixel.area #area of W in cm^2
laslett = laslett(Y, plotit = F) #Lasletts transformation
W.prime.prime = laslett$Rect
x.point <- laslett$df$newx
y.point <- laslett$df$y
X <- ppp(x.point, y.point, W.prime.prime)
plot(X, main = "")
no.points.W.prime.prime <- X$n #135
area.W.prime.prime = area(W.prime.prime)*pixel.area #cm^2
##------------------------------------------------##
#### Test for Complete Spacial Randomness (CSR) ####
##------------------------------------------------##
#------------------------------------#
####         Method 3:            ####
#
# Clark And Evans Test
#------------------------------------#
clarkevans.test(X) #alternative="two.sided"
clarkevans.test(X, correction="D", nsim = 10^4) #alternative="two.sided" + Donnelly correction
clarkevans.test(X, alternative="clustered")
clarkevans.test(X, alternative="clustered", correction="D", nsim = 10^4)
##-----------------------------------------------------##
#### Estimation of the Intensity and volume fraction ####
##-----------------------------------------------------##
#Estimate for the intensity
gamma.hat = no.points.W.prime.prime/area.W.prime.prime #57.5285
#Estimate for the volume fraction p
no.black.particles <- sum(thres.im < 1) #number of black particles in the thresholded image
#Note: sum(thres.im) gives the number of white pixels
p.hat <- no.black.particles/area(W) #Because area.W.pix = no.black.particles + no.white.particles = total number of particles in W
##-----------------------##
#### Varians Estimates ####
##-----------------------##
#----------------#
#### Method 1 ####
#----------------#
#Estimate of r_0
r.zero.hat <- sqrt(-(log(1-p.hat))/(gamma.hat*pi))
#Covariogram fct for B^2
F2 <- function(x){
if(0 < x && x < 2*r.zero.hat){
F2 <- ((4*x)/(pi*r.zero.hat^2))*(acos(x/(2*r.zero.hat)) - (x/(2*r.zero.hat))*sqrt(1-(x^2/(4*r.zero.hat^2))))
} else{
F2 <- 0
}
return(F2)
}
F2 <- Vectorize(F2);
curve(F2, 0-0.1, 2*r.zero.hat+0.1)
int <- function(x){
return((exp(gamma.hat*r.zero.hat^2*(F2(x/r.zero.hat)))-1)*x)
}
int <- integrate(int, 0, Inf)$value #1.51875e-05
#Estimate of sigma
sigma.hat <- 2*pi*(1-p.hat)^2*int #3.689225e-05
#Confidence interval
KI = c(p.hat - qnorm(0.975)*sqrt(1/area.W)*sqrt(sigma.hat), p.hat + qnorm(0.975)*sqrt(1/area.W)*sqrt(sigma.hat)) #[0.3752955 , 0.3811508]
W.one <- owin(c(0.5, 690.5-r.zero.hat), c(0.5, 233-r.zero.hat))
W.two <- owin(c(690.5+r.zero.hat, 1381.5), c(0.5, 233+r.zero.hat))
W.one <- Y[W.one]
plot(W.one)
W.two <- Y[W.two]
plot(W.two)
W.one
W.one
xless = 690.5-r.zero.hat
xless
W.one <- owin(c(0.5, x.less), c(0.5, 233-r.zero.hat))
xless = 690.5-r.zero.hat
W.one <- owin(c(0.5, x.less), c(0.5, 233-r.zero.hat))
x.less = 690.5-r.zero.hat
W.one <- owin(c(0.5, x.less), c(0.5, 233-r.zero.hat))
W.one
x.geater = 690.5 + r.zero.hat
x.greater
x.geater = 690.5 + r.zero.hat
x.greater
x.greater = 690.5 + r.zero.hat
x.greater
W.three <- owin(c(W$xrange[1], x.less), c(W$yrange[1], y.less))
W.one <- owin(c(W$xrange[1], x.less), c(y.greater, W$yrange[2]))
x.less = 690.5-r.zero.hat
x.greater = 690.5 + r.zero.hat
y.less = 233 - r.zero.hat
y.greater = 233 + r.zero.hat
W.three <- owin(c(W$xrange[1], x.less), c(W$yrange[1], y.less))
W.one <- owin(c(W$xrange[1], x.less), c(y.greater, W$yrange[2]))
W.one
x.less = 690.5-r.zero.hat
x.greater = 690.5 + r.zero.hat
y.less = 233 - r.zero.hat
y.greater = 233 + r.zero.hat
W.one <- owin(c(W$xrange[1], x.less), c(y.greater, W$yrange[2]))
W.three <- owin(c(W$xrange[1], x.less), c(W$yrange[1], y.less))
W.two <- owin(c(x.greater, W$xrange[2]), c(y.greater, W$xrange[2]))
W.four <- owin(c(x.greater, W$xrange[2]), c(W$yrange[1], y.less))
W.one
W.two
W.three
W.four
layout(matrix(c(1:4), ncol=2))
layout(matrix(c(1:4), ncol=2))
W.one <- Y[W.one]
W.two <- Y[W.two]
W.three <- Y[W.three]
W.four <- Y[W.four]
plot(W.one)
plot(W.two)
plot(W.three)
plot(W.four)
plot(Y[W])
layout(matrix(c(1:6), ncol=2))
W.one <- Y[W.one]
W.two <- Y[W.two]
W.three <- Y[W.three]
W.four <- Y[W.four]
plot(W.one)
plot(W.two)
plot(W.three)
plot(W.four)
plot(Y[W])
setwd("C:/Users/livmb/Dropbox/UNI/Speciale/Brød billeder/brød")
library(imager)
library(spatstat)
#Sets layout in plots (3x3 matrix)
layout(matrix(c(1:3), ncol=3))
#Loads Original image, which is a Window of a bread image
im <- load.image("BlåBrødPågen7cmTop.JPG")
##-------------------------------------------------------------
#### Picture Manipulation ####
##-------------------------------------------------------------
# Plots Original image, extracted Blue channel image and the
# thresholded version of this. The threshold is here determined
# by Kmeans.
##-------------------------------------------------------------
layout(matrix(c(1:3), ncol=3))
plot(im, xlab = "", ylab = "")
BRGim <- B(im) - (R(im)+G(im)) #Extracting the blue colorchanel in the Original Image
BRGim.normalize <- (BRGim - min(BRGim))/(max(BRGim)-min(BRGim)) #Normalizes to image values
plot(BRGim.normalize, xlab = "", ylab = "")
thres.im <- threshold(BRGim.normalize, thr = "auto") #Thresholded Image
plot(thres.im, xlab = "", ylab = "")
##-------------------------------------------------------------
# Plotting the thresholded image in a observation
# window, W, and then performing Lasletts test.
##-------------------------------------------------------------
layout(1)
thres.im <- cimg2im(thres.im) #Change the image type
W <- owin(c(thres.im$xrange[1], thres.im$xrange[2]), c(thres.im$yrange[1], thres.im$yrange[2])) #defining the obs window W, here we just look at the whole image
Y <- thres.im[W]
top.length = 7 #cm
top.pix <- W$xrange[2]-W$xrange[1] #1381 pix
pixel.width = top.length/top.pix #How many cm the width of one pixel is
pixel.height = pixel.width #pixels are quadratic
pixel.area = pixel.width * pixel.height #area of one pixel in cm^2
area.W <- area(W)*pixel.area #area of W in cm^2
laslett = laslett(Y, plotit = F) #Lasletts transformation
W.prime.prime = laslett$Rect
x.point <- laslett$df$newx
y.point <- laslett$df$y
X <- ppp(x.point, y.point, W.prime.prime)
plot(X, main = "")
no.points.W.prime.prime <- X$n #135
area.W.prime.prime = area(W.prime.prime)*pixel.area #cm^2
##------------------------------------------------##
#### Test for Complete Spacial Randomness (CSR) ####
##------------------------------------------------##
#------------------------------------#
####         Method 3:            ####
#
# Clark And Evans Test
#------------------------------------#
clarkevans.test(X) #alternative="two.sided"
clarkevans.test(X, correction="D", nsim = 10^4) #alternative="two.sided" + Donnelly correction
clarkevans.test(X, alternative="clustered")
clarkevans.test(X, alternative="clustered", correction="D", nsim = 10^4)
##-----------------------------------------------------##
#### Estimation of the Intensity and volume fraction ####
##-----------------------------------------------------##
#Estimate for the intensity
gamma.hat = no.points.W.prime.prime/area.W.prime.prime #57.5285
#Estimate for the volume fraction p
no.black.particles <- sum(thres.im < 1) #number of black particles in the thresholded image
#Note: sum(thres.im) gives the number of white pixels
p.hat <- no.black.particles/area(W) #Because area.W.pix = no.black.particles + no.white.particles = total number of particles in W
##-----------------------##
#### Varians Estimates ####
##-----------------------##
#----------------#
#### Method 1 ####
#----------------#
#Estimate of r_0
r.zero.hat <- sqrt(-(log(1-p.hat))/(gamma.hat*pi))
#Covariogram fct for B^2
F2 <- function(x){
if(0 < x && x < 2*r.zero.hat){
F2 <- ((4*x)/(pi*r.zero.hat^2))*(acos(x/(2*r.zero.hat)) - (x/(2*r.zero.hat))*sqrt(1-(x^2/(4*r.zero.hat^2))))
} else{
F2 <- 0
}
return(F2)
}
F2 <- Vectorize(F2);
curve(F2, 0-0.1, 2*r.zero.hat+0.1)
int <- function(x){
return((exp(gamma.hat*r.zero.hat^2*(F2(x/r.zero.hat)))-1)*x)
}
int <- integrate(int, 0, Inf)$value #1.51875e-05
#Estimate of sigma
sigma.hat <- 2*pi*(1-p.hat)^2*int #3.689225e-05
#Confidence interval
KI = c(p.hat - qnorm(0.975)*sqrt(1/area.W)*sqrt(sigma.hat), p.hat + qnorm(0.975)*sqrt(1/area.W)*sqrt(sigma.hat)) #[0.3752955 , 0.3811508]
#----------------#
#### Method 2 ####
#----------------#
t.zero <- 2*r.zero.hat
x.less = 690.5-r.zero.hat
x.greater = 690.5 + r.zero.hat
y.less = 233 - r.zero.hat
y.greater = 233 + r.zero.hat
W.one <- owin(c(W$xrange[1], x.less), c(y.greater, W$yrange[2]))
W.three <- owin(c(W$xrange[1], x.less), c(W$yrange[1], y.less))
W.two <- owin(c(x.greater, W$xrange[2]), c(y.greater, W$xrange[2]))
W.four <- owin(c(x.greater, W$xrange[2]), c(W$yrange[1], y.less))
layout(matrix(c(1:4), ncol=2))
W.one <- Y[W.one]
W.two <- Y[W.two]
W.three <- Y[W.three]
W.four <- Y[W.four]
plot(W.one)
plot(W.two)
plot(W.three)
plot(W.four)
plot(Y)
W.one
